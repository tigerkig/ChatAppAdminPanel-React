{"ast":null,"code":"// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nexport var path = {\n  basename: basename,\n  dirname: dirname,\n  extname: extname,\n  join: join,\n  sep: '/'\n};\n/**\n * @param {string} path\n * @param {string} [ext]\n * @returns {string}\n */\n\nfunction basename(path, ext) {\n  var start = 0;\n  var end = -1;\n  /** @type {number} */\n\n  var index;\n  /** @type {number} */\n\n  var firstNonSlashEnd;\n  /** @type {boolean} */\n\n  var seenNonSlash;\n  /** @type {number} */\n\n  var extIndex;\n\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string');\n  }\n\n  assertPath(path);\n  index = path.length;\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47\n      /* `/` */\n      ) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1;\n          break;\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true;\n        end = index + 1;\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end);\n  }\n\n  if (ext === path) {\n    return '';\n  }\n\n  firstNonSlashEnd = -1;\n  extIndex = ext.length - 1;\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47\n    /* `/` */\n    ) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1;\n        break;\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true;\n        firstNonSlashEnd = index + 1;\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index;\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1;\n          end = firstNonSlashEnd;\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd;\n  } else if (end < 0) {\n    end = path.length;\n  }\n\n  return path.slice(start, end);\n}\n/**\n * @param {string} path\n * @returns {string}\n */\n\n\nfunction dirname(path) {\n  /** @type {number} */\n  var end;\n  /** @type {boolean} */\n\n  var unmatchedSlash;\n  /** @type {number} */\n\n  var index;\n  assertPath(path);\n\n  if (path.length === 0) {\n    return '.';\n  }\n\n  end = -1;\n  index = path.length; // Prefix `--` is important to not run on `0`.\n\n  while (--index) {\n    if (path.charCodeAt(index) === 47\n    /* `/` */\n    ) {\n      if (unmatchedSlash) {\n        end = index;\n        break;\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true;\n    }\n  }\n\n  return end < 0 ? path.charCodeAt(0) === 47\n  /* `/` */\n  ? '/' : '.' : end === 1 && path.charCodeAt(0) === 47\n  /* `/` */\n  ? '//' : path.slice(0, end);\n}\n/**\n * @param {string} path\n * @returns {string}\n */\n\n\nfunction extname(path) {\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1; // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n\n  var preDotState = 0;\n  /** @type {boolean} */\n\n  var unmatchedSlash;\n  /** @type {number} */\n\n  var code;\n  /** @type {number} */\n\n  var index;\n  assertPath(path);\n  index = path.length;\n\n  while (index--) {\n    code = path.charCodeAt(index);\n\n    if (code === 47\n    /* `/` */\n    ) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1;\n        break;\n      }\n\n      continue;\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true;\n      end = index + 1;\n    }\n\n    if (code === 46\n    /* `.` */\n    ) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1;\n    }\n  }\n\n  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.\n  preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n\n  return path.slice(startDot, end);\n}\n/**\n * @param {Array.<string>} segments\n * @returns {string}\n */\n\n\nfunction join() {\n  var index = -1;\n  /** @type {string} */\n\n  var joined;\n\n  for (var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) {\n    segments[_key] = arguments[_key];\n  }\n\n  while (++index < segments.length) {\n    assertPath(segments[index]);\n\n    if (segments[index]) {\n      joined = joined === undefined ? segments[index] : joined + '/' + segments[index];\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined);\n}\n/**\n * Note: `normalize` is not exposed as `path.normalize`, so some code is\n * manually removed from it.\n *\n * @param {string} path\n * @returns {string}\n */\n\n\nfunction normalize(path) {\n  /** @type {boolean} */\n  var absolute;\n  /** @type {string} */\n\n  var value;\n  assertPath(path);\n  absolute = path.charCodeAt(0) === 47;\n  /* `/` */\n  // Normalize the path according to POSIX rules.\n\n  value = normalizeString(path, !absolute);\n\n  if (value.length === 0 && !absolute) {\n    value = '.';\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47\n  /* / */\n  ) {\n    value += '/';\n  }\n\n  return absolute ? '/' + value : value;\n}\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n * @param {boolean} allowAboveRoot\n * @returns {string}\n */\n\n\nfunction normalizeString(path, allowAboveRoot) {\n  var result = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var index = -1;\n  /** @type {number} */\n\n  var code;\n  /** @type {number} */\n\n  var lastSlashIndex;\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index);\n    } else if (code === 47\n    /* `/` */\n    ) {\n      break;\n    } else {\n      code = 47;\n      /* `/` */\n    }\n\n    if (code === 47\n    /* `/` */\n    ) {\n      if (lastSlash === index - 1 || dots === 1) {// Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46\n        /* `.` */\n        || result.charCodeAt(result.length - 2) !== 46\n        /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/');\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = '';\n                lastSegmentLength = 0;\n              } else {\n                result = result.slice(0, lastSlashIndex);\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');\n              }\n\n              lastSlash = index;\n              dots = 0;\n              continue;\n            }\n          } else if (result.length > 0) {\n            result = '';\n            lastSegmentLength = 0;\n            lastSlash = index;\n            dots = 0;\n            continue;\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index);\n        } else {\n          result = path.slice(lastSlash + 1, index);\n        }\n\n        lastSegmentLength = index - lastSlash - 1;\n      }\n\n      lastSlash = index;\n      dots = 0;\n    } else if (code === 46\n    /* `.` */\n    && dots > -1) {\n      dots++;\n    } else {\n      dots = -1;\n    }\n  }\n\n  return result;\n}\n/**\n * @param {string} path\n */\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}","map":{"version":3,"sources":["E:/dev/admin_panel/LocalsAdminPanel/node_modules/vfile/lib/minpath.browser.js"],"names":["path","basename","dirname","extname","join","sep","ext","start","end","index","firstNonSlashEnd","seenNonSlash","extIndex","undefined","TypeError","assertPath","length","charCodeAt","slice","unmatchedSlash","startDot","startPart","preDotState","code","joined","segments","normalize","absolute","value","normalizeString","allowAboveRoot","result","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","JSON","stringify"],"mappings":"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","sourcesContent":["// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/**\n * @param {string} path\n * @param {string} [ext]\n * @returns {string}\n */\nfunction basename(path, ext) {\n  var start = 0\n  var end = -1\n  /** @type {number} */\n  var index\n  /** @type {number} */\n  var firstNonSlashEnd\n  /** @type {boolean} */\n  var seenNonSlash\n  /** @type {number} */\n  var extIndex\n\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  index = path.length\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  firstNonSlashEnd = -1\n  extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction dirname(path) {\n  /** @type {number} */\n  var end\n  /** @type {boolean} */\n  var unmatchedSlash\n  /** @type {number} */\n  var index\n\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  end = -1\n  index = path.length\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction extname(path) {\n  var startDot = -1\n  var startPart = 0\n  var end = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  var preDotState = 0\n  /** @type {boolean} */\n  var unmatchedSlash\n  /** @type {number} */\n  var code\n  /** @type {number} */\n  var index\n\n  assertPath(path)\n\n  index = path.length\n\n  while (index--) {\n    code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * @param {Array.<string>} segments\n * @returns {string}\n */\nfunction join(...segments) {\n  var index = -1\n  /** @type {string} */\n  var joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Note: `normalize` is not exposed as `path.normalize`, so some code is\n * manually removed from it.\n *\n * @param {string} path\n * @returns {string}\n */\nfunction normalize(path) {\n  /** @type {boolean} */\n  var absolute\n  /** @type {string} */\n  var value\n\n  assertPath(path)\n\n  absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n * @param {boolean} allowAboveRoot\n * @returns {string}\n */\nfunction normalizeString(path, allowAboveRoot) {\n  var result = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var index = -1\n  /** @type {number} */\n  var code\n  /** @type {number} */\n  var lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {string} path\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}